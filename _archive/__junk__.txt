########### from EM_field.py >> class vector_potential ##########################
    def gradient(self,x):
        """
        Derivative with respect to position
        The Jacobian matrix will have the form:

        dAx/drx & dAx/dry & dAx/drz
        dAy/drx & dAy/dry & dAy/drz  
        dAz/drx & dAz/dry & dAz/drz

        Tips: dH/dr = dH/dA . dA/dr
        where dA/dr = k*sth is this matrix
        """

        kx = self.k @ x
        kx = np.tile(kx.reshape(-1,1),(1,2))

        Ckx =  self.C * np.exp(kx * np.array(1.j))
        Ckx -=  np.conjugate(self.C) * np.exp(kx * np.array(-1.j))
        Ckx *= np.array(1.j)

        Ckx = Ckx.reshape(*self.epsilon.shape[:-1], -1)
        Ckx = self.epsilon * Ckx 

        """
        if self.n_mode == 1:
            Ckx = np.sum(Ckx, axis = 0)
            dAdr = np.outer(Ckx, self.k )
        else:
        """
        Ckx = np.sum(Ckx, axis = 1)
        dAdr = []
        for i in range(len(Ckx)):
            dAdr.append(np.outer(Ckx[i,:], self.k[i,:]))
        dAdr = np.array(dAdr)
        dAdr = np.sum(dAdr, axis = 0)

        return dAdr



def __call__(self,x):
        kx = self.k @ x # matmul
        # [kx] -> [[kx]] -> [[kx], [kx]]
        kx = np.tile(kx.reshape(-1,1),(1,2))

        #following the formula [[C_ke1], [C_ke2]] * [[kx], [kx]]
        Ckx = self.C * np.exp(kx * np.array(1.j))
        Ckx += np.conjugate(self.C) * np.exp(kx * np.array(-1.j))

        #reshape to (N x 2 x 1) match with epsilon shape (N x 2 x 3) 
        # => element-wise multiplication
        Ckx = Ckx.reshape(*self.epsilon.shape[:-1], -1)
        Ckx = np.tile(Ckx, (1,1,3))
        Ckx = self.epsilon * Ckx 

        # sum over the axis 1 => sum over polarization vector
        result = np.sum(Ckx, axis = 1) # sum C_l [e^{ikx} e_l + c.c.] for each mode
        result = np.sum(result, axis = 0) # sum over all mode


def f(ra, va, C):
    jk = A.transverse_project(
        (1/(2*np.pi**1.5)) * np.exp(-1j * k_vec @ ra) * qa * va
        )

    return - 1j * omega * C + \
        np.einsum('ijk,kj->ik', np.tile(jk[:,:,np.newaxis],(1,1,2)), epsilon)

##############################################################################################
class EquationOfMotion:
    def __init__(self, q,  k_vec, epsilon):
        self.q = q
        self.n_points = len(q)

        self.k_vec = k_vec

        self.epsilon = epsilon

    def compose_state_vector(self, C, r, v):
        assert len(r) == self.n_points and len(v) == self.n_points
        r = np.hstack(r)
        v = np.hstack(v)
        return np.hstack([C, v, r])

    def decompose_state_vector(self,state_vector):
        C = state_vector[0:2]
        v = state_vector[2:2+self.n_points * 3].reshape(-1,3)
        r = state_vector[2+self.n_points * 3:].reshape(-1,3)
        return C,v,r

    def __call__(self, state_vector):
        C,v,r = self.decompose_state_vector(state_vector)
        C_dot = dot_C(
            q = self.q, 
            k_vec = self.k_vec, 
            epsilon = self.epsilon,
            C = C, r = r, v = v
        )
        ma = compute_force(
            q = self.q, 
            k_vec = self.k_vec, 
            epsilon = self.epsilon,
            C = C, r = r, v = v
        )
        v.reshape(
        return np.hstack([C_dot, ma, v])
        
